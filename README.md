# iOSTech

A useful tools or tips list for iOS application developing

这个项目收集iOS开发所需要的一些资源与小技巧

----

## 为什么你要拒绝我

- [Why-Reject](https://github.com/jcccn/Why-Reject) ----- *苹果AppStore被拒理由大全*

## 工具类

- [SimPholders2](http://simpholders.com/) ----- *模拟器文件目录埋的太深，用这个工具可以直接定位到模拟器目录。*
- [Makeappicon](http://makeappicon.com/) ----- *上传一张1024x1024的图片，自动生成Icon Png。*
- [Appscreens](https://appscreens.io/) ----- *提交AppStore时所需要的截图，可以使用此工具。*
- [Reveal](http://revealapp.com/) ----- *调试UI可以用的工具，在运行时动态修改，不用重新编译，非常方便。*
- [PixelWinch](http://www.ricciadams.com/projects/pixel-winch) ----- *这个工具可以测量像素。*
- [DHC](https://www.sprintapi.com/dhcs.html) ----- *这个工具主要来测试网络请求。*
- [JSON格式化](http://www.runoob.com/tool/json/index.html) ----- *格式化JSON，看起来不会很吃力。*
- [TinyPNG](https://tinypng.com/) ----- *这个工具可以用来压缩图片质量*
- [Pixelmator](http://support.pixelmator.com/) ----- *这个工具可以用来切图或者查看设计稿*

## Xcode 插件类

- [Alcatraz](https://github.com/supermarin/Alcatraz) ----- *这个差距可以用来管理Xcode其他所有的插件。*
- [KSImageNamed-Xcode](https://github.com/ksuther/KSImageNamed-Xcode) ----- *使用UIImage时可以自动提示已经导入的图片。*
- [ColorSense-for-Xcode](https://github.com/omz/ColorSense-for-Xcode) ----- *使用UIColor时可以弹出Xcode的颜色选择器。*
- [SCXcodeMiniMap](https://github.com/stefanceriu/SCXcodeMiniMap) ----- *给Xcode增加一个mini小地图。*
- [VVDocumenter-Xcode](https://github.com/onevcat/VVDocumenter-Xcode) ----- *快捷的编写文档注释。*
- [XToDo](https://github.com/trawor/XToDo) ----- *快速的查看To Do列表。*
- [XAlign](https://github.com/qfish/XAlign) ----- *可以快速的使代码对其。*
- [cocoapods-xcode-plugin](https://github.com/kattrali/cocoapods-xcode-plugin) ----- *方法查看和管理pod安装的第三方库。*
- [Ciapre-Xcode-theme](https://github.com/vinhnx/Ciapre-Xcode-theme) ----- *这是我个人非常喜欢的一个主题。*
- [WakaTime](https://github.com/wakatime/xcode-wakatime) ----- *记录编程时间*

## Xcode 操作类

快速阅读

- [14个Xcode中常用的快捷键操作](http://www.cocoachina.com/ios/20141224/10752.html)
- [Objective-C常用代码片段](https://github.com/Xcode-Snippets/Objective-C)
- [Swift常用代码片段](https://github.com/burczyk/XcodeSwiftSnippets)

深入全面的阅读

- [iOS开发进阶，从Xcode开始](http://www.cocoachina.com/special/xcode/) ----- *这是一个非常全面的专题，Xcode 6.0+ 的使用。*

## 时间都去哪儿了

`wakatime`可以记录编程的时间，当然不仅仅是iOS开发。

* 关于如何安装可以参考：[https://wakatime.com/help/plugins/xcode](https://wakatime.com/help/plugins/xcode)

## 编程风格与最佳实践

编程风格

- [Google Objective-C编程风格指南](http://zh-google-styleguide.readthedocs.org/en/latest/google-objc-styleguide/contents/)
- [RayWenderlich 官方 Swift 编程风格指南](http://swift.gg/2015/08/11/raywenderlich-swift-style-guide/)
- [Google C++编程风格指南](http://zh-google-styleguide.readthedocs.org/en/latest/google-cpp-styleguide/contents/)

最佳实践

- [禅与 Objective-C 编程艺术](https://github.com/oa414/objc-zen-book-cn)
- [C 语言常见问题集](http://c-faq-chn.sourceforge.net/ccfaq/index.html)

## CocoaPods中国源

- [https://gitcafe.com/akuandev/Specs.git](https://gitcafe.com/akuandev/Specs.git)
- [http://git.oschina.net/akuandev/Specs.git](http://git.oschina.net/akuandev/Specs.git)

安装CocaoPods时所使用的源

- [http://ruby.taobao.org/](http://ruby.taobao.org/)

关于使用，可以阅读[用CocoaPods做iOS程序的依赖管理](http://blog.devtang.com/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/)

## 来自田伟宇的一些经验总结干货

- [iOS应用架构谈（一）：架构设计的方法论](http://www.infoq.com/cn/articles/ios-app-arch-part-01)
- [iOS应用架构谈（二）：View层的组织和调用方案（上）](http://www.infoq.com/cn/articles/ios-app-arch-2-1?utm_source=infoq&utm_medium=related_content_link&utm_campaign=relatedContent_articles_clk)
- [iOS应用架构谈（二）：View层的组织和调用方案（中）](http://www.infoq.com/cn/articles/ios-app-arch-2-2?utm_source=infoq&utm_medium=related_content_link&utm_campaign=relatedContent_articles_clk)
- [iOS应用架构谈（二）：View层的组织和调用方案（下）](http://www.infoq.com/cn/articles/ios-app-arch-2-3?utm_source=infoq&utm_medium=related_content_link&utm_campaign=relatedContent_articles_clk)
- [iOS应用架构谈（三）：网络层设计方案](http://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html)
- [iOS应用架构谈（四）：本地持久化方案及动态部署](http://casatwy.com/iosying-yong-jia-gou-tan-ben-di-chi-jiu-hua-fang-an-ji-dong-tai-bu-shu.html)

## iOS尺寸，适配的问题

关于尺寸可以阅读一下译文。

- [图标和图像尺寸](http://deeper29.com/2015/04/29/icon-and-image-sizes/)
- [移动端尺寸基础知识](http://colachan.com/post/3435)

现在的iOS开发适配都开始使用Auto Layout来描述布局，苹果官方也非常推荐使用。

- [iOS 开发实践之 Auto Layout](http://xuexuefeng.com/autolayout/)

当然，深入到具体，大家都用Masonry代码的方式来做布局，因为苹果的约束布局非常繁琐。

- [Masonry介绍与使用实践(快速上手Autolayout)](http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/)

也有朋友习惯使用storyboard来绘制和约束UI，可以阅读一下一个系列文章

- [Auto Layout 使用心得（一）—— 初体验](http://lvwenhan.com/ios/430.html)
- [Auto Layout 使用心得（二）—— 实现三等分](http://lvwenhan.com/ios/431.html)
- [Auto Layout 使用心得（三）—— 自定义 cell 并使用 Auto Layout](http://lvwenhan.com/ios/441.html)
- [Auto Layout 使用心得（四）—— 22 行代码实现拖动回弹](http://lvwenhan.com/ios/442.html)
- [Auto Layout 使用心得（五）—— 根据文字、图片自动计算 UITableViewCell 高度](http://lvwenhan.com/ios/449.html)
- [Auto Layout 使用心得（六）—— 制造炫酷的下拉刷新动画](http://lvwenhan.com/ios/450.html)

关于切图和适配方面可以阅读一下两个攻略

- [fitview-iOS切图攻略-关于适配的一些方式](fitview)

## 常用高效率的宏定义与小技巧系列

- [iOS开发中常用的一些宏定义](https://github.com/XFZLDXF/Macro/blob/master/MacroDefinition.h)
- [记录各种iOS开发技巧](https://github.com/koknine/NOTE)

## 分离TableView

为了减轻ViewController的代码量与工作量，实现的思路是把TableView的datasource和delegate分离成一个类去处理，通过注册的方式把UITableViewCell注册到TableView中。

	-(void)registerCellClassUsingCellIdentifier:(NSArray *)cellClassArray
	{
    	for (Class identifier in cellClassArray) {
        	[self registerClass:identifier forCellReuseIdentifier:NSStringFromClass(identifier)];
    }
	}

	-(void)registerForTableViewAtExtend:(id)tableViewExtend
	{
    	self.dataSource = tableViewExtend;
    	self.delegate = tableViewExtend;
	}

TableView分离的类：

	#import <Foundation/Foundation.h>

	@class POITable;
	@class POIModelManager;

	@interface POITableExtend : NSObject<UITableViewDataSource,UITableViewDelegate>

	@property(copy,nonatomic) NSString *identifier;
	@property(strong,nonatomic) POITable *tableView;
	@property(strong,nonatomic) POIModelManager *manager;

	- (id)initWithTableView:(POITable*)tableView cellIdentifier:(Class)cellIdentifier;

	@end

- [简单实现的Demo](https://github.com/icepy/withoutMe/tree/master/MVVMTableView)
- [更轻量的 View Controllers](http://objccn.io/issue-1-1/)
- [整洁的 Table View 代码](http://objccn.io/issue-1-2/)

## 关于BaseViewController

一般在定义ViewController的时候都习惯于定义一个BaseViewController作为基类，这样做的好处是可以把公共属性提取出来，这样的代码结构会更清晰。

某些情况下，其他的类无法继承于BaseViewController，而又想拥有它的属性或方法。

- [关于iOS“多继承”的实现方式](http://www.jianshu.com/p/2e9382be43b)
- [Objective-C 的“多继承”](http://blog.csdn.net/yiyaaixuexi/article/details/8970734)

一些好用的BaseViewController源代码

在模拟器的调试模式下运行时，将自动模拟内存警告。

	- (void)viewDidAppear:(BOOL)animated
	{
  		[super viewDidAppear:animated];

    	#if TARGET_IPHONE_SIMULATOR
        	#ifdef DEBUG
            	// If we are running in the simulator and it's the DEBUG target
            	// then simulate a memory warning. Note that the DEBUG flag isn't
            	// defined by default. To define it add this Preprocessor Macro for
            	// the Debug target: DEBUG=1
            	[self simulateMemoryWarning];
        	#endif
    	#endif
	}

	- (void)simulateMemoryWarning
	{
    	#if TARGET_IPHONE_SIMULATOR
        	#ifdef DEBUG
            	CFNotificationCenterPostNotification(CFNotificationCenterGetDarwinNotifyCenter(), (CFStringRef)@"UISimulatedMemoryWarningNotification", NULL, NULL, true);
        	#endif
    	#endif
	}

设置导航控制器的标题

	- (void)setTitle
	{
		UILabel *titleLabel = [[UILabel alloc] initWithFrame:CGRectZero];
    	titleLabel.font = [UIFont boldSystemFontOfSize:18.0f];
    	titleLabel.backgroundColor = [UIColor clearColor];
    	titleLabel.textColor = [UIColor blackColor];
    	titleLabel.text = title;
    	[titleLabel sizeToFit];
    	self.navigationItem.titleView = titleLabel;
	}
	
设置返回按钮

	- (void)setLeftBackBtn
	{
    	UIButton *backBtn = [UIButton buttonWithType:UIButtonTypeCustom];
    	backBtn.frame = CGRectMake(0, 0, 20, 20);
    	[backBtn setImage:[UIImage imageNamed:@"global_back_white"] forState:UIControlStateNormal];
    	[backBtn addTarget:self action:@selector(backBarClick) forControlEvents:UIControlEventTouchUpInside];
    	self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc]initWithCustomView:backBtn];
	}
	
	- (void)backBarClick
	{
    	if (self.navigationController.viewControllers.count > 1) {
        	[self.navigationController popViewControllerAnimated:YES];
    	}
	}

> 定义一个block typedef void (^Normalblock)(void)
	
设置自定义左边按钮与标题

	- (void)setLeftButtonTitle:(NSString *)title clickCallBack:(Normalblock)block
	{
    	UIButton *leftBtn = [UIButton buttonWithType:UIButtonTypeCustom];
    	leftBtn.frame = CGRectMake(0, 0, 50, 20);
    	leftBtn.titleLabel.font = [UIFont systemFontOfSize:16];
    	[leftBtn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
    	[leftBtn setTitle:title forState:UIControlStateNormal];
    	[leftBtn addTarget:self action:@selector(leftBtnClick) forControlEvents:UIControlEventTouchUpInside];
    	UIBarButtonItem *left = [[UIBarButtonItem alloc]initWithCustomView:leftBtn];
    	self.navigationItem.leftBarButtonItem = left;
    	_LeftBlock = block;
	}
	
	- (void)leftBtnClick
	{
    	if (_LeftBlock == nil) {
        	[self.navigationController popViewControllerAnimated:YES];
        	return;
    	}
    	_LeftBlock();
	}

设置自定义右边按钮与标题

	- (void)setRightButtonTitle:(NSString *)title clickCallBack:(Normalblock)block
	{
    	UIButton *rightBtn = [UIButton buttonWithType:UIButtonTypeCustom];
    	rightBtn.frame = CGRectMake(0, 0, 50, 20);
    	rightBtn.titleLabel.font = [UIFont systemFontOfSize:16];
    	[rightBtn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
    	[rightBtn setTitle:title forState:UIControlStateNormal];
    	[rightBtn addTarget:self action:@selector(rightBtnClick) forControlEvents:UIControlEventTouchUpInside];
    	UIBarButtonItem *right = [[UIBarButtonItem alloc]initWithCustomView:rightBtn];
    	self.navigationItem.rightBarButtonItem = right;
    	_RightBlock = block;
	}
	
	- (void)rightBtnClick{
    	_RightBlock();
	}

## Mantle使用

[Mantle](https://github.com/Mantle/Mantle)可以快速的将JSON转化成Model类，节省了很多重复编码的时间。

- [Mantle 初步使用](http://ourui.github.io/blog/2014/01/22/mantle-use/)
- [工具篇：Mantle](http://southpeak.github.io/blog/2015/01/11/gong-ju-pian-:mantle/)
- [使用Mantle处理Model层对象](http://blog.codingcoder.com/use-mantle-to-model/)

三步走即可，第一步继承MTLModel并且实现MTLJSONSerializing协议

	@interface JSONDataModel : MTLModel<MTLJSONSerializing>

	@property (nonatomic, strong) NSDate *date;
	
	@end
	
第二步，在.m文件中实现MTLJSONSerializing协议的+ (NSDictionary *)JSONKeyPathsByPropertyKey方法

	@implementation JSONDataModel
	
	+ (NSDictionary *)JSONKeyPathsByPropertyKey 
	{
		return @{
			@"data":@"trueData" //JSON与Model一个一对应
		}
	}
	@end
	
第三步，如果有特殊需求，比如类型转换，Mantle也提供了很多便捷的方法（可选实现）

	+ (NSValueTransformer *)dateJSONTransformer {
    	return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSNumber *dateNum) {
        	return [NSDate dateWithTimeIntervalSince1970:dateNum.floatValue];
    	} reverseBlock:^(NSDate *date) {
        	return [NSString stringWithFormat:@"%f",[date timeIntervalSince1970]];
    	}];
	}
	
## Debug UI Reveal

Reveal 是一个界面调试工具，使用Reveal，我们可以在iOS开发时动态地查看和修改应用程序的界面。它类似Chrome的“审查元素”功能，我们不但可以在运行时看到iOS程序的界面层级关系，还可以实时地修改程序界面，不用重新运行程序就可以看到修改之后的效果。

请阅读

- [Reveal：分析iOS UI的利器](http://security.ios-wiki.com/issue-3-4/)
- [Reveal查看任意app的高级技巧](http://c.blog.sina.com.cn/profile.php?blogid=cb8a22ea89000gtw)

使用pod安装一下它的SDK，就可以连接了。

	pod 'Reveal-iOS-SDK', '~> 1.5.1'
	
## Category添加属性

有时候写了一个分类，发现属性不够用，那怎么办？这时候可以使用Runtime特性了。

	#import <objc/runtime.h>
	
建立一个Category头文件

	@interface ClassTest (CategoryTest)
	
	@property (nonatomic, strong) NSString *testString;
	
	@end
	
在实现文件中添加testString的getter和setter方法
	
	
	static const void *IndieBandNameKey = &IndieBandNameKey;
	@implementation ClassTest (CategoryTest) 
	
	@dynamic testString;
	
	-(void)setTestString:(NSString *)str  
	{  
    	objc_setAssociatedObject(self, IndieBandNameKey, str, OBJC_ASSOCIATION_COPY);  
	}	  

	-(NSString *)testString  
	{  
    	return objc_getAssociatedObject(self, IndieBandNameKey);  
	}
	
	@end
	
	
`objc_setAssociatedObject`方法有四个参数：源对象，关联时的用来标记是哪一个属性的key（因为你可能要添加很多属性），关联的对象和一个关联策略。

关联策略枚举

	enum {
    	OBJC_ASSOCIATION_ASSIGN = 0, //关联对象的属性是弱引用 

    	OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, //关联对象的属性是强引用并且关联对象不使用原子性

    	OBJC_ASSOCIATION_COPY_NONATOMIC = 3, //关联对象的属性是copy并且关联对象不使用原子性

    	OBJC_ASSOCIATION_RETAIN = 01401, //关联对象的属性是copy并且关联对象使用原子性

    	OBJC_ASSOCIATION_COPY = 01403 //关联对象的属性是copy并且关联对象使用原子性
	};
	
## 判断UIScrollView是向上滚动还是向下滚动

25 可以是任意数字，可根据自己的需要来设定。

	int _lastPosition;    //A variable define in headfile  

	- (void)scrollViewDidScroll:(UIScrollView *)scrollView
	{  
    	int currentPostion = scrollView.contentOffset.y;  
    	if (currentPostion - _lastPosition > 25) {  
        	_lastPosition = currentPostion;  
        	NSLog(@"ScrollUp now");  
    	}  else if (_lastPosition - currentPostion > 25){  
        	_lastPosition = currentPostion;  
        	NSLog(@"ScrollDown now");  
    	}  
	}

到达顶部或底部时不会反弹

	- (void)scrollViewDidScroll:(UIScrollView *)scrollView
	{
    	int currentPostion = scrollView.contentOffset.y;

    	if (currentPostion - _lastPosition > 20  && currentPostion > 0) {        //这个地方加上 currentPostion > 0 即可）
        	_lastPosition = currentPostion;

        	NSLog(@"ScrollUp now");
    	}else if ((_lastPosition - currentPostion > 20) && (currentPostion  <= scrollView.contentSize.height-scrollView.bounds.size.height-20) ){
       		_lastPosition = currentPostion;
	
        	NSLog(@"ScrollDown now");
    	}
	}
	
## UIScrollView添加约束的正确方式

- 首先,scrollView自身的约束(scrollView的位置和尺寸)可以像正常的UIView一样参照其父控件添加.
- 其次,scrollView内部子控件约束的添加需要遵循两个原则:
	- scrollView内部子控件的尺寸不能以scrollView的尺寸为参照
	- scrollView内部的子控件的约束必须完整

代码案例：


	__block NSUInteger curr = 0;
    NSUInteger length = self.imageArray.count -1;
    for (UIButton *currButton in self.imageArray) {
        [currButton mas_makeConstraints:^(MASConstraintMaker *make) {
            NSUInteger nextPage = curr + 1;
            NSUInteger prepPage = curr - 1;
            if (curr > 0) {
                UIButton *prepButton = (UIButton *)[self.imageArray objectAtIndex:prepPage];
                if (length == curr) {
                    make.left.equalTo(prepButton.mas_right).with.offset(0);
                    make.right.mas_equalTo(0);
                }else{
                    UIButton *nextButton = (UIButton *)[self.imageArray objectAtIndex:nextPage];
                    make.left.equalTo(prepButton.mas_right).with.offset(0);
                    make.right.equalTo(nextButton.mas_left).with.offset(0);
                }
            }else{
                UIButton *nextButton = (UIButton *)[self.imageArray objectAtIndex:nextPage];
                make.left.mas_equalTo(0);
                make.right.equalTo(nextButton.mas_left).with.offset(0);
            }
            make.top.mas_equalTo(0);
            make.height.mas_equalTo(@230);
            make.width.equalTo(self.scrollSuperview.mas_width);
            curr++;
        }];
    }

## NavigationController

- 利用storyboard添加NavigationController

在storyboard中选择一个UIViewController，然后在Xcode工具栏上选择Editor -> Embed in -> Navigation Controller，Xcode会帮助我们创建UINavigationController。

然后在自己UIViewController中直接使用`self.navigationController` 

- 在AppDelegate中使用代码添加

关于层叠结构（理论不做论述），先从window中取出来初始化时的rootViewController，然后将它添加到初始化的NavigationController中，最后将NavigationController添加到window的rootViewController中。

```Swift
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
   // Override point for customization after application launch.
  let navC:UINavigationController = UINavigationController(rootViewController:(self.window?.rootViewController)!)
  self.window?.rootViewController = navC
  return true
}
```

- navigationBar

navigationBar是一个全局的属性，这也意味着你修改navigationBar中的属性将作用在之后所有的UIViewController中。

```Swift
self.navigationController?.navigationBar.barStyle = .Default
self.navigationController?.navigationBar.tintColor = UIColor.redColor()
self.navigationController?.setNavigationBarHidden(<#T##hidden: Bool##Bool#>, animated: <#T##Bool#>)
```

- navigationItem

每一个UIViewController中都有一个navigationController属性，而navigationItem相当于是在navigationController中管理的对应的`UIViewController`，修改这个唯一的属性，只会作用在当前的UIViewController中，不会修改之后的。

```Swift
self.navigationItem.title = "imageView"
self.navigationItem.leftBarButtonItem = UIBarButtonItem(title: "返回",style:UIBarButtonItemStyle.Done, target: self, action: "backHandler")

func backHandler(){
   self.navigationController?.popViewControllerAnimated(true)
}        
```
## Method Swizzling

- class_replaceMethod 替换类方法的定义
- method_exchangeImplementations 交换 2 个方法的实现
- method_setImplementation 设置 1 个方法的实现

Objective-C

```Objective-C
/**
 *  交换两个方法
 */
+(void)load
{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        Method viewDidLoad = class_getInstanceMethod(self, @selector(viewDidLoad));
        Method viewDidLoaed = class_getInstanceMethod(self, @selector(viewDidLoaed));
        method_exchangeImplementations(viewDidLoad, viewDidLoaed);
    });
}

-(void)viewDidLoaed
{
    [self viewDidLoaed];
    NSLog(@"%@ did load",self);
}


+(void)load
{
    static dispatch_once_t onceToKen;
    dispatch_once(&onceToKen, ^{
        Method viewDidLoad = class_getInstanceMethod(self, @selector(viewDidLoad));
        _VIMP viewDidLoad_VIMP = (_VIMP)method_getImplementation(viewDidLoad);
        method_setImplementation(viewDidLoad, imp_implementationWithBlock(^(id target,SEL selector){
            viewDidLoad_VIMP(target,selector);
            NSLog(@"IMP ---> %@",target);
        }));
    });
}
```
Siwft

```Swift
// MARK: - 交换两个方法

extension UIViewController{
    public override class func initialize(){
        struct Static{
            static var token:dispatch_once_t = 0
        }
        if self != UIViewController.self{
            return
        }
        dispatch_once(&Static.token, {
            _ in
            let viewDidLoad = class_getInstanceMethod(self, Selector("viewDidLoad"))
            let viewDidLoaded = class_getInstanceMethod(self, Selector("viewDidLoaded"))
            method_exchangeImplementations(viewDidLoad,viewDidLoaded)
        })
    }
    func viewDidLoaded(){
        self.viewDidLoaded()
        print("init --- > \(self)")
    }
}


// MARK: - 使用IMP

typealias _IMP = @convention(c)(id:AnyObject,sel:UnsafeMutablePointer<Selector>)->AnyObject
typealias _VIMP = @convention(c)(id:AnyObject,sel:UnsafeMutablePointer<Selector>)->Void

extension UIViewController{
    public override class func initialize(){
        struct Static{
            static var token:dispatch_once_t = 0
        }
        if self != UIViewController.self{
            return
        }
        
        dispatch_once(&Static.token, {
            _ in
            let viewDidLoad:Method = class_getInstanceMethod(self, Selector("viewDidLoad"))
            let viewDidLoad_VIMP:_VIMP = unsafeBitCast(method_getImplementation(viewDidLoad),_VIMP.self)
            let block:@convention(block)(UnsafeMutablePointer<AnyObject>,UnsafeMutablePointer<Selector>)->Void = {
                (id,sel) in
                viewDidLoad_VIMP(id: id.memory, sel: sel)
                print("viewDidLoad func execu over id ---> \(id.memory)");
            }
            let imp:COpaquePointer = imp_implementationWithBlock(unsafeBitCast(block, AnyObject.self))
            method_setImplementation(viewDidLoad,imp)
        })
    }
    
    private struct Associa{
        static var Name:String = "UIStackView_Name"
    }
    
    var name:String{
        get{
            return objc_getAssociatedObject(self,&Associa.Name) as! String
        }
        set(newValue){
            objc_setAssociatedObject(self, &Associa.Name, newValue as String?, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)
        }
    }
}
```

可用方法列表：

```Objectice-C
//判断类中是否包含某个方法的实现
BOOL class_respondsToSelector(Class cls, SEL sel)
//获取类中的方法列表
Method *class_copyMethodList(Class cls, unsigned int *outCount) 
//为类添加新的方法,如果方法该方法已存在则返回NO
BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)
//替换类中已有方法的实现,如果该方法不存在添加该方法
IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types) 
//获取类中的某个实例方法(减号方法)
Method class_getInstanceMethod(Class cls, SEL name)
//获取类中的某个类方法(加号方法)
Method class_getClassMethod(Class cls, SEL name)
//获取类中的方法实现
IMP class_getMethodImplementation(Class cls, SEL name)
//获取类中的方法的实现,该方法的返回值类型为struct
IMP class_getMethodImplementation_stret(Class cls, SEL name) 

//获取Method中的SEL
SEL method_getName(Method m) 
//获取Method中的IMP
IMP method_getImplementation(Method m)
//获取方法的Type字符串(包含参数类型和返回值类型)
const char *method_getTypeEncoding(Method m) 
//获取参数个数
unsigned int method_getNumberOfArguments(Method m)
//获取返回值类型字符串
char *method_copyReturnType(Method m)
//获取方法中第n个参数的Type
char *method_copyArgumentType(Method m, unsigned int index)
//获取Method的描述
struct objc_method_description *method_getDescription(Method m)
//设置Method的IMP
IMP method_setImplementation(Method m, IMP imp) 
//替换Method
void method_exchangeImplementations(Method m1, Method m2)

//获取SEL的名称
const char *sel_getName(SEL sel)
//注册一个SEL
SEL sel_registerName(const char *str)
//判断两个SEL对象是否相同
BOOL sel_isEqual(SEL lhs, SEL rhs) 

//通过块创建函数指针,block的形式为^ReturnType(id self,参数,...)
IMP imp_implementationWithBlock(id block)
//获取IMP中的block
id imp_getBlock(IMP anImp)
//移出IMP中的block
BOOL imp_removeBlock(IMP anImp)

//调用target对象的sel方法
id objc_msgSend(id target, SEL sel, 参数列表...)
```


## Runtime

Objective-C的类都是由Class类型来表示的，它是一个指向objc_class结构体的指针，定义如下：

```Objective-C
typedef struct objc_class *Class;
```

objc_class结构体定义如下：

```Objective-C
struct objc_class {
	Class isa  OBJC_ISA_AVAILABILITY;
#if !__OBJC2__
	Class super_class                       OBJC2_UNAVAILABLE;  // 父类
	const char *name                        OBJC2_UNAVAILABLE;  // 类名
	long version                            OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0
	long info                               OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识
	long instance_size                      OBJC2_UNAVAILABLE;  // 该类的实例变量大小
	struct objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  // 该类的成员变量链表
	struct objc_method_list **methodLists   OBJC2_UNAVAILABLE;  // 方法定义的链表
	struct objc_cache *cache                OBJC2_UNAVAILABLE;  // 方法缓存
	struct objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  // 协议链表
#endif

} OBJC2_UNAVAILABLE;
```

如何操作类：

```Objectice-C
Class newClass = objc_allocateClassPair([NSError class], "AMNClass", 0); // 创建新的类
class_addMethod(newClass, @selector(testMetaClass), (IMP)TestMetaClass, "v@:"); // 为新的类添加方法
objc_registerClassPair(newClass); // 注册创建的类
id instance = [[newClass alloc] initWithDomain:@"some domain" code:0 userInfo:nil]; // 实例化对象
[instance performSelector:@selector(testMetaClass)]; // 调用方法
// 获取类的类名
const char * class_getName ( Class cls );
// 获取类的父类
Class class_getSuperclass ( Class cls );
// 判断给定的Class是否是一个元类
BOOL class_isMetaClass ( Class cls );
// 获取实例大小
size_t class_getInstanceSize ( Class cls );

```

在`objc_class`中，所有的成员变量、属性的信息是放在链表ivars中的。ivars是一个class_copylvarList函数，它返回一个指向成员变量信息的数组。

```Objective-C
// 获取指定的属性
objc_property_t class_getProperty ( Class cls, const char *name );
// 获取属性列表
objc_property_t * class_copyPropertyList ( Class cls, unsigned int *outCount );
// 为类添加属性
BOOL class_addProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );
// 替换类的属性
void class_replaceProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );
// 添加方法
BOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types );
// 获取实例方法
Method class_getInstanceMethod ( Class cls, SEL name );
// 获取类方法
Method class_getClassMethod ( Class cls, SEL name );
// 获取所有方法的数组
Method * class_copyMethodList ( Class cls, unsigned int *outCount );
// 替代方法的实现
IMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types );
// 返回方法的具体实现
IMP class_getMethodImplementation ( Class cls, SEL name );
IMP class_getMethodImplementation_stret ( Class cls, SEL name );
// 类实例是否响应指定的selector
BOOL class_respondsToSelector ( Class cls, SEL sel );
```
`class_addMethod`的实现会覆盖父类的方法实现，但不会取代本类中已存在的实现。如果要修改已经存在的实现，可以使用`method_setImplementation`

```Objective-C
// 添加协议
BOOL class_addProtocol ( Class cls, Protocol *protocol );
// 返回类是否实现指定的协议
BOOL class_conformsToProtocol ( Class cls, Protocol *protocol );
// 返回类实现的协议列表
Protocol * class_copyProtocolList ( Class cls, unsigned int *outCount );
// 获取版本号
int class_getVersion ( Class cls );
// 设置版本号
void class_setVersion ( Class cls, int version );
// 创建一个新类和元类
Class objc_allocateClassPair ( Class superclass, const char *name, size_t extraBytes );
// 销毁一个类及其相关联的类
void objc_disposeClassPair ( Class cls );
// 在应用中注册由objc_allocateClassPair创建的类
void objc_registerClassPair ( Class cls );
// 创建类实例
id class_createInstance ( Class cls, size_t extraBytes );
// 在指定位置创建类实例
id objc_constructInstance ( Class cls, void *bytes );
// 销毁类实例
void * objc_destructInstance ( id obj );
// 返回指定对象的一份拷贝
id object_copy ( id obj, size_t size );
// 释放指定对象占用的内存
id object_dispose ( id obj );
// 修改类实例的实例变量的值
Ivar object_setInstanceVariable ( id obj, const char *name, void *value );
// 获取对象实例变量的值
Ivar object_getInstanceVariable ( id obj, const char *name, void **outValue );
// 返回指向给定对象分配的任何额外字节的指针
void * object_getIndexedIvars ( id obj );
// 返回对象中实例变量的值
id object_getIvar ( id obj, Ivar ivar );
// 设置对象中实例变量的值
void object_setIvar ( id obj, Ivar ivar, id value )
// 返回给定对象的类名
const char * object_getClassName ( id obj );
// 返回对象的类
Class object_getClass ( id obj );
// 设置对象的类
Class object_setClass ( id obj, Class cls );
// 获取已注册的类定义的列表
int objc_getClassList ( Class *buffer, int bufferCount );
// 创建并返回一个指向所有已注册类的指针列表
Class * objc_copyClassList ( unsigned int *outCount );
// 返回指定类的类定义
Class objc_lookUpClass ( const char *name );
Class objc_getClass ( const char *name );
Class objc_getRequiredClass ( const char *name );
// 返回指定类的元类
Class objc_getMetaClass ( const char *name );
```
